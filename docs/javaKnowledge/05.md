# 异常深度剖析

项目参考地址：https://github.com/zhaobao1830/misszb

## 分类

异常分类Throwable分为Error与Exception

Error:一般系统级别，我们无法处理

Exception：一般应用层面，我们可以处理      

Exception分为：CheckException与RuntimeException 

CheckException：必须处理，如果不处理，在编译阶段就会报错

处理异常的时候，可以在当前位置进行处理，比如记录日志；也可以通过throws Exception往外抛异常，但总有一个地方要对异常进行处理

RuntimeException：运行时异常，不一定能在编译阶段发现，也不要求强制进行处理

::: tip 备注
只要没有继承RuntimeException，那就是CheckException

如果异常在编译阶段就要处理，那就定义成CheckException
:::

## 全局异常处理

GlobalExceptionAdvice.java

```java
package com.zb.misszb.core;

import com.zb.misszb.exception.http.HttpException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;

import javax.servlet.http.HttpServletRequest;

@ControllerAdvice
public class GlobalExceptionAdvice {

    @ExceptionHandler(Exception.class)
    @ResponseBody
    @ResponseStatus(code = HttpStatus.INTERNAL_SERVER_ERROR)
    public UnifyResponse handleException(HttpServletRequest req, Exception e) {
        String requestUrl = req.getRequestURI();
        String method = req.getMethod();
        UnifyResponse message = new UnifyResponse(9999, "服务器异常", method + " "+ requestUrl);
        return message;
    }

    @ExceptionHandler(HttpException.class)
    public void handleHttpException(HttpServletRequest req, Exception e) {
        System.out.println("系统出现错误！");
    }
}

```

### @ControllerAdvice、@ExceptionHandler、@ResponseStatus

@ControllerAdvice用来注册全局异常类

@ExceptionHandler用来在方法上指定监听哪种异常，比如@ExceptionHandler(HttpException.class)，监听的就是HttpException异常，

只要请求的方法里报HttpException类以及子类的异常，就会被这个方法捕获

使用@ResponseStatus注解指定返回的错误码，比如系统错误，就返回500，不要统一都是200

### 为什么要把接口返回的信息都变成异常来处理？

有的项目里，会把返回信息和异常分开处理，缺点是：需要区分什么是异常，什么是正常的返回信息

还有处理方式，就是所有的返回都按异常处理，已知异常就返回message信息和code码，未知异常除了返回信息，还会将错误保存在日志文件里


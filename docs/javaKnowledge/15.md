# JWT令牌的生成与校验

项目地址：[https://github.com/zhaobao1830/misszb](https://github.com/zhaobao1830/misszb)

## JWT令牌的生成

**token.controller**

通过LoginType判断是微信小程序获取token还是普通的登录获取token，当前实现的是微信小程序获取token

```java
@PostMapping("")
    public Map<String, String> getToken(@RequestBody @Validated TokenGetDTO userData) {
        Map<String, String> map = new HashMap<>();
        String token = null;
        System.out.println(userData.getLoginType());
        switch (userData.getLoginType()) {
            case USER_WX:
                token = wxAuthenticationService.code2Session(userData.getAccount());
                break;
            case USER_Email:
                break;
            default:
                throw new NotFoundException(10003);
        }
        map.put("token", token);
        return map;
    }
```

::: tip 备注
为什么要要返回map，因为map返回到前端是对象形式，好取值
:::

**TokenGetDTO.java**

```java
package com.zb.misszb.dto;

import com.zb.misszb.core.enumeration.LoginType;
import com.zb.misszb.dto.validators.TokenPassword;
import lombok.Getter;
import lombok.Setter;

import javax.validation.constraints.NotBlank;

@Getter
@Setter
public class TokenGetDTO {
    @NotBlank(message = "account不允许为空")
    private String account;
    @TokenPassword(min=5, max=30, message = "{token.password}")
    private String password;

    private LoginType loginType;
}

```

说明：

account code值或账号

password 密码 微信小程序端不用传

loginType 登录方式 微信小程序端传0，其他端传1

loginType.java

```java
package com.zb.misszb.core.enumeration;

public enum  LoginType {
    USER_WX(0, "微信登录"),
    USER_Email(1, "邮箱登录");

    private Integer value;

    LoginType(Integer value, String description) {
        this.value = value;
    }
}

```

**wxAuthenticationService.java**

功能：

1、访问微信服务器，通过code换取openid和uuid

2、通过openid查询user：如果存在，就通过user的id生成jwt；如果不存在，就先把user保存到数据库里，再通过user的id生成jwt

```java
package com.zb.misszb.service.authentication.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.zb.misszb.exception.http.ParameterException;
import com.zb.misszb.model.User;
import com.zb.misszb.repository.UserRepository;
import com.zb.misszb.service.authentication.WxAuthenticationService;
import com.zb.misszb.util.JwtToken;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.text.MessageFormat;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

@Service
public class WxAuthenticationServiceImpl implements WxAuthenticationService {

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private UserRepository userRepository;

    @Value("${wx.code2session}")
    private String code2SessionUrl;
    @Value("${wx.appid}")
    private String appid;
    @Value("${wx.appSecret}")
    private String appSecret;

    @Override
    public String code2Session(String code) {
        String url = MessageFormat.format(this.code2SessionUrl, this.appid, this.appSecret, code);
        RestTemplate rest = new RestTemplate();
        String sessionText = rest.getForObject(url, String.class);
        Map<String, Object> session = new HashMap<>();
        try {
            session = objectMapper.readValue(sessionText, HashMap.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        return this.registerUser(session);
    }

    private String registerUser(Map<String, Object> session) {
        String openid = (String) session.get("openid");
        if (openid == null) {
            throw new ParameterException(20004);
        }
        Optional<User> userOptional = userRepository.findByOpenid(openid);
        if (userOptional.isPresent()) {
            System.out.println(userOptional.get().getId());
            // TODO:返回JWT令牌
            return JwtToken.makeToken(userOptional.get().getId());
        }
        User user = User.builder()
                .openid(openid)
                .build();
        userRepository.save(user);
        // TODO:返回JWT令牌
        Long uid = user.getId();
        return JwtToken.makeToken(uid);
    }
}

```

**JwtToken.java**

包含具体生成jwt的方法

```java
package com.zb.misszb.util;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtToken {

    // jwt加密使用的Key
    private static String jwtKey;

    // jwt过期时间
    private static Integer expiredTimeIn;

    private static Integer defaultScope = 8;

    // 将配置文件里的值注入并赋值给jwtKey
    @Value("${misszb.security.jwt-key}")
    public void setJwtKey(String jwtKey) {
        JwtToken.jwtKey = jwtKey;
    }

    @Value("${misszb.security.token-expired-in}")
    public void setExpiredTimeIn(Integer expiredTimeIn) {
        JwtToken.expiredTimeIn = expiredTimeIn;
    }

    /**
     * 生成token
     * @param uid 用户标识
     * @param scope 用户等级，不同的用户按等级分类，给予不同的token
     * @return
     */
    public static String makeToken(Long uid, Integer scope) {
        return JwtToken.getToken(uid, scope);
    }

    // 当前项目里没有用户等级，这个方法传入默认用户等级
    public static String makeToken(Long uid) {
        return JwtToken.getToken(uid, JwtToken.defaultScope);
    }

    private static String getToken(Long uid, Integer scope) {
        Algorithm algorithm = Algorithm.HMAC256(JwtToken.jwtKey);
        Map<String, Date> map = JwtToken.calculateExpiredIssues();

        return JWT.create()
                .withClaim("uid", uid)
                .withClaim("scope", scope)
                .withExpiresAt(map.get("expiredTime"))
                .withIssuedAt(map.get("now"))
                .sign(algorithm);
    }

    private static Map<String, Date> calculateExpiredIssues() {
        Map<String, Date> map = new HashMap<>();
        // Calendar类为抽象类，不能实例化，想获取对象可以用getInstance方法
        Calendar calendar = Calendar.getInstance();
        // 获取当前时间
        Date now = calendar.getTime();
        // 动态修改当前时间，传入的参数为秒
        calendar.add(Calendar.SECOND, JwtToken.expiredTimeIn);
        map.put("now", now);
        map.put("expiredTime", calendar.getTime());
        return map;
    }
}

```

## 令牌生成过程

**一、微信小程序端：调用wx.login获取code值**

```js
  onGetToken() {
    // code
    wx.login({
      success: (res) => {
        if (res.code) {
          wx.request({
            url: 'http://localhost:8082/v1/token',
            method: 'POST',
            data: {
              account: res.code,
              loginType: 0
            },
            success: (res) => {
              console.log(res.data)
            }
          })
        }
      }
    })
  }
```

**二、调用获取token接口。微信小程序端：传入code值和loinType；其他端传入账号、密码和loginType**

```js
  wx.request({
  url: 'http://localhost:8082/v1/token',
  method: 'POST',
  data: {
    account: res.code,
    loginType: 0
  },
  success: (res) => {
    console.log(res.data)
  }
})     
```

**说明：**

account code值或账号

password 密码 微信小程序端不用传

loginType 登录方式 微信小程序端传0，其他端传1

**三、微信小程序端：后端访问微信服务器，调用https://api.weixin.qq.com/sns/jscode2session方法，使用code值换取openid和uuid**

```java
    @Value("${wx.code2session}")
    private String code2SessionUrl;
    @Value("${wx.appid}")
    private String appid;
    @Value("${wx.appSecret}")
    private String appSecret;
    
    @Override
    public String code2Session(String code) {
        String url = MessageFormat.format(this.code2SessionUrl, this.appid, this.appSecret, code);
        RestTemplate rest = new RestTemplate();
        String sessionText = rest.getForObject(url, String.class);
        Map<String, Object> session = new HashMap<>();
        try {
            session = objectMapper.readValue(sessionText, HashMap.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        return this.registerUser(session);
    }
```

**说明：**

**（一）、替换占位符**

MessageFormat.format()根据顺序和占位符进行值的替换

code2SessionUrl为https://api.weixin.qq.com/sns/jscode2session?appid={0}&secret={1}&js_code={2}&grant_type=authorization_code

MessageFormat.format()方法第一个参数是需要被替换的值(String类型)，其他参数是按顺序要替换成的值

```String url = MessageFormat.format(this.code2SessionUrl, this.appid, this.appSecret, code);```生成的是访问微信服务器获取的url

可以获取用户的openid和unionid，文档地址是：[https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html)

**（二）、java发起请求**

```java
  RestTemplate rest = new RestTemplate();
  String sessionText = rest.getForObject(url, String.class);
```

java要想发起请求，需要使用RestTemplate，掉用getForObject()方法，第一个参数是请求的url，第二个参数是返回的类型的元类

**（三）、将字符串转换成HashMap**

```java
@Autowired
private ObjectMapper objectMapper;
    
Map<String, Object> session = new HashMap<>();
session = objectMapper.readValue(sessionText, HashMap.class);
```

ObjectMapper是jackson里的方法，objectMapper.readValue()方法将字符串转换成相应格式的对象，第一个参数是需要转换的字符串，第二个参数是转换成的格式

**四、微信小程序端：通过openid判断数据库是否有对应的user，如果有就用user的id生成jwt；如果没有：就先保存到user表，再通过user的id生成jwt；**
**其他端是通过账号和密码判断是否有对应的user，如果有就用user的id生成jwt；如果没有：就先保存到user表，再通过user的id生成jwt**

```java
 private String registerUser(Map<String, Object> session) {
        String openid = (String) session.get("openid");
        if (openid == null) {
            throw new ParameterException(20004);
        }
        Optional<User> userOptional = userRepository.findByOpenid(openid);
        if (userOptional.isPresent()) {
            System.out.println(userOptional.get().getId());
            // TODO:返回JWT令牌
            return JwtToken.makeToken(userOptional.get().getId());
        }
        User user = User.builder()
                .openid(openid)
                .build();
        userRepository.save(user);
        // TODO:返回JWT令牌
        Long uid = user.getId();
        return JwtToken.makeToken(uid);
    }
```

**说明：**

**（一）、Optional的缺陷**

在jsk8里面，Optional的orElseThrow当有值的时候会直接返回数值，没有值的时候可以传入处理函数

如果即想在有值的时候进行处理，又想在无值的时候处理，orElseThrow方法无法满足，这时候可以使用isPresent方法(是否有值)

::: tip 备注
jdk11里，Optional新加了方法，可以传入俩个函数，处理有值和无值。不过只能进行简单的逻辑处理，如果想处理负责逻辑，还是建议if/else配合isPresent方法使用
:::

**（二）、实体数据的赋值和保存**

```java
User user = User.builder()
                .openid(openid)
                .build();
        userRepository.save(user);
        // TODO:返回JWT令牌
        Long uid = user.getId();       
```

builder创建对象，给这个对象的openid赋值，使用save方法保存后，就可以获取到当前对象的id

**五、生成token**

```java
package com.zb.misszb.util;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtToken {

    // jwt加密使用的Key
    private static String jwtKey;

    // jwt过期时间
    private static Integer expiredTimeIn;

    private static Integer defaultScope = 8;

    // 将配置文件里的值注入并赋值给jwtKey
    @Value("${misszb.security.jwt-key}")
    public void setJwtKey(String jwtKey) {
        JwtToken.jwtKey = jwtKey;
    }

    @Value("${misszb.security.token-expired-in}")
    public void setExpiredTimeIn(Integer expiredTimeIn) {
        JwtToken.expiredTimeIn = expiredTimeIn;
    }

    /**
     * 生成token
     * @param uid 用户标识
     * @param scope 用户等级，不同的用户按等级分类，给予不同的token
     * @return
     */
    public static String makeToken(Long uid, Integer scope) {
        return JwtToken.getToken(uid, scope);
    }

    // 当前项目里没有用户等级，这个方法传入默认用户等级
    public static String makeToken(Long uid) {
        return JwtToken.getToken(uid, JwtToken.defaultScope);
    }

    private static String getToken(Long uid, Integer scope) {
        Algorithm algorithm = Algorithm.HMAC256(JwtToken.jwtKey);
        Map<String, Date> map = JwtToken.calculateExpiredIssues();

        return JWT.create()
                .withClaim("uid", uid)
                .withClaim("scope", scope)
                .withExpiresAt(map.get("expiredTime"))
                .withIssuedAt(map.get("now"))
                .sign(algorithm);
    }

    private static Map<String, Date> calculateExpiredIssues() {
        Map<String, Date> map = new HashMap<>();
        // Calendar类为抽象类，不能实例化，想获取对象可以用getInstance方法
        Calendar calendar = Calendar.getInstance();
        // 获取当前时间
        Date now = calendar.getTime();
        // 动态修改当前时间，传入的参数为秒
        calendar.add(Calendar.SECOND, JwtToken.expiredTimeIn);
        map.put("now", now);
        map.put("expiredTime", calendar.getTime());
        return map;
    }
}

```

**说明：**

**（一）、加密生成签名**

```java
import com.auth0.jwt.algorithms.Algorithm;

Algorithm algorithm = Algorithm.HMAC256(JwtToken.jwtKey);
```

使用Algorithm的HMAC256方法进行加密，参数是自己定义的一段值

**（二）、使用Calendar处理时间**

```java
   private static Map<String, Date> calculateExpiredIssues() {
        Map<String, Date> map = new HashMap<>();
        // Calendar类为抽象类，不能实例化，想获取对象可以用getInstance方法
        Calendar calendar = Calendar.getInstance();
        // 获取当前时间
        Date now = calendar.getTime();
        // 动态修改当前时间，传入的参数为秒
        calendar.add(Calendar.SECOND, JwtToken.expiredTimeIn);
        map.put("now", now);
        map.put("expiredTime", calendar.getTime());
        return map;
    }
```

**（二）、JWT赋值**

```java
JWT.create()
   .withClaim("uid", uid)
   .withClaim("scope", scope)
   .withExpiresAt(map.get("expiredTime"))
   .withIssuedAt(map.get("now"))
   .sign(algorithm);             
```

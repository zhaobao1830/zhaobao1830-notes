import{_ as t,o as e,c as a,R as c}from"./chunks/framework.3AywRrgj.js";const r="/zhaobao1830-notes/assets/01.lbyj_ms8.png",h="/zhaobao1830-notes/assets/02.tlCD46Mc.jpg",o="/zhaobao1830-notes/assets/03.z2jqo7Bc.jpg",g=JSON.parse('{"title":"watch和watchEffect","description":"","frontmatter":{},"headers":[],"relativePath":"vueKnowledge/04.md","filePath":"vueKnowledge/04.md","lastUpdated":1703836988000}'),s={name:"vueKnowledge/04.md"},p=c('<h1 id="watch和watcheffect" tabindex="-1">watch和watchEffect <a class="header-anchor" href="#watch和watcheffect" aria-label="Permalink to &quot;watch和watchEffect&quot;">​</a></h1><h2 id="watcheffect" tabindex="-1">watchEffect <a class="header-anchor" href="#watcheffect" aria-label="Permalink to &quot;watchEffect&quot;">​</a></h2><p>官网：<a href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect" target="_blank" rel="noreferrer">https://cn.vuejs.org/api/reactivity-core.html#watcheffect</a></p><p>watchEffect是立即执行函数，页面渲染后就执行，并响应式地追踪其依赖</p><p>vue在页面退出，执行了销毁操作时，会把effect销毁</p><p>第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求</p><p><img src="'+r+'" alt="Image text"></p><p>比如在watchEffect函数中发起axios请求，如果请求结果没有返回，可以在请求方法后面进行取消操作</p><p>第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。</p><p>默认情况下，侦听器将在组件渲染之前执行。设置 <code>flush: &#39;post&#39;</code> 将会使侦听器延迟到组件渲染之后再执行。</p><p>flush可选值为：&#39;pre&#39; | &#39;post&#39; | &#39;sync&#39; // 默认：&#39;pre&#39;</p><p>备注：如果想在watchEffect中监听组件上的ref，可以把flush设置为&#39;post&#39;</p><p>因为<a href="https://cn.vuejs.org/api/built-in-special-attributes.html#ref" target="_blank" rel="noreferrer">ref</a>本身是作为渲染函数的结果来创建的，必须等待组件挂载后才能对它进行访问。</p><h2 id="watch" tabindex="-1">watch <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;watch&quot;">​</a></h2><p>官网：<a href="https://cn.vuejs.org/api/reactivity-core.html#watch" target="_blank" rel="noreferrer">https://cn.vuejs.org/api/reactivity-core.html#watch</a></p><p>watch如果想监听reactive里的单个值，可以用getter函数或者toRefs</p><p><img src="'+h+'" alt="Image text"></p><p><img src="'+o+'" alt="Image text"></p><h2 id="watch和watcheffect对比" tabindex="-1">watch和watchEffect对比 <a class="header-anchor" href="#watch和watcheffect对比" aria-label="Permalink to &quot;watch和watchEffect对比&quot;">​</a></h2><p>watch可以获取数据变化前后的值</p><p>watch 在响应数据初始化时是不会执行回调函数的(可以通过设置immediate:true立即执行回调)，watchEffect 在响应数据初始化时就会立即执行回调函数。</p>',21),f=[p];function i(n,l,w,_,d,m){return e(),a("div",null,f)}const b=t(s,[["render",i]]);export{g as __pageData,b as default};

import{_ as t,o as e,c as o,R as s}from"./chunks/framework.1nBpG9uI.js";const r="/zhaobao1830-notes/assets/01.gBp_2SRf.png",p="/zhaobao1830-notes/assets/02.RnQJJabl.png",a="/zhaobao1830-notes/assets/03.gizkex_x.png",n="/zhaobao1830-notes/assets/04._IwqTDp1.png",i="/zhaobao1830-notes/assets/05.zGH1fcGy.png",l="/zhaobao1830-notes/assets/06.6lcdqd29.png",h="/zhaobao1830-notes/assets/07.lf24obI7.png",c="/zhaobao1830-notes/assets/08.6koWiO-A.png",g="/zhaobao1830-notes/assets/09.Vc6DE2ro.png",d="/zhaobao1830-notes/assets/10.e81dNjOr.png",T=JSON.parse('{"title":"项目架构演进历程","description":"","frontmatter":{},"headers":[],"relativePath":"javaKnowledge/34.md","filePath":"javaKnowledge/34.md","lastUpdated":1709100863000}'),m={name:"javaKnowledge/34.md"},_=s('<h1 id="项目架构演进历程" tabindex="-1">项目架构演进历程 <a class="header-anchor" href="#项目架构演进历程" aria-label="Permalink to &quot;项目架构演进历程&quot;">​</a></h1><h2 id="叙述" tabindex="-1">叙述 <a class="header-anchor" href="#叙述" aria-label="Permalink to &quot;叙述&quot;">​</a></h2><p><strong>1、最开始是静态网页，是单向的。服务器仅仅提供内容给用户查阅</strong></p><p><img src="'+r+'" alt="Image text"></p><p><strong>2、用户与服务器之间是双向交互，用户可以对数据CRUD</strong></p><p><img src="'+p+'" alt="Image text"></p><p><strong>3、早期java web-----用户访问服务器，服务器中有打包成war的项目，有html js css等，也有MVC处理用户请求，文件服务器保存用户头像、文件等，数据库则保存用户信息</strong></p><p><img src="'+a+'" alt="Image text"></p><p><strong>4、实现前后端分离，可以对请求进行一定程度的降压---将文件服务器与服务器分离，服务器仅仅提供网站信息，文件服务器保存用户信息</strong></p><p><img src="'+a+'" alt="Image text"></p><p><strong>5、引入缓存钟中间件，等于是防护机制。用户请求首先会在缓存中查询，然后才会在数据库查询。</strong></p><p><img src="'+n+'" alt="Image text"></p><p><strong>6、单节点遇到瓶颈，使用集群实现负载均衡。读写会直接与数据库交互，用户百万、千万以上如何解决负载能力？</strong></p><p><img src="'+i+'" alt="Image text"></p><p><strong>7、数据库读写分离，主从复制。读占8，写占2，数据库拆分为读写数据库，主库会定时向从库进行数据同步</strong></p><p><img src="'+l+'" alt="Image text"></p><p><strong>8、随着业务增长，数据库压力大，对数据库进行分库分表,主库从库都要拆成数据库集群，实现分布式数据库。此时主键不能使用自增主键而是全局唯一主键</strong></p><p><img src="'+h+'" alt="Image text"></p><p><strong>9、用户会数据的检索出现多样化，数据库增加模糊查询等需求，引入搜索引擎技术。在提供搜索的时候，还要为数据库增加保护措施</strong></p><p><img src="'+c+'" alt="Image text"></p><p><strong>10、大型项目拆成微服务的一个个集群，数据库也需要进行拆分，作为单独的商品、订单等数据库。此时需要考虑分布式事务。（微服务）</strong></p><p><img src="'+g+'" alt="Image text"></p><p><strong>11、对JVM Tomcat 和数据库进行调优</strong></p><p><img src="'+d+'" alt="Image text"></p><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><h3 id="单体架构" tabindex="-1">单体架构 <a class="header-anchor" href="#单体架构" aria-label="Permalink to &quot;单体架构&quot;">​</a></h3><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h4><p>1、小团队成型即可完成开发-测试-上线</p><p>2、迭代周期短,速度快</p><p>3、打包方便,运维省事</p><h4 id="挑战" tabindex="-1">挑战 <a class="header-anchor" href="#挑战" aria-label="Permalink to &quot;挑战&quot;">​</a></h4><p>1、单节点宕机会造成所有服务不可用</p><p>2、耦合度太高(迭代,测试,部署)</p><p>3、单节点并发能力有限，负载量不够，并发过高，会导致服务奔溃、宕机</p><h4 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h4><p>1、通过集群实现高可用</p><p>2、使用分布式或微服务进行改进</p><p>3、负载均衡降低服务器的负载压力，分发用户的请求到其他计算机节点</p><h3 id="集群" tabindex="-1">集群 <a class="header-anchor" href="#集群" aria-label="Permalink to &quot;集群&quot;">​</a></h3><h4 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h4><p>1、提高系统性能，可以分发流量到各个节点</p><p>2、提高系统可用性，避免像单体那样,一个服务宕机，整个项目都挂掉了</p><p>3、可扩展性高/提高系统可伸缩性，可以在流量高峰期，适当增加计算机节点来支持高峰期的流量（比如微博，当明星出现大新闻时，这时流量大）</p><h4 id="注意点" tabindex="-1">注意点 <a class="header-anchor" href="#注意点" aria-label="Permalink to &quot;注意点&quot;">​</a></h4><p>1、用户会话使用分布式会话(redis缓存实现redis分布式会话)</p><p>2、定时任务：当定时任务到达定时节点的时候，含有定时任务的集群节点，会将任务都执行一次，可能会造成数据不一致(定时任务：操作)，或降低系统性能(定时任务: 查询)</p><p>3、内网必须互通</p>',47),b=[_];function x(u,q,f,I,k,P){return e(),o("div",null,b)}const j=t(m,[["render",x]]);export{T as __pageData,j as default};

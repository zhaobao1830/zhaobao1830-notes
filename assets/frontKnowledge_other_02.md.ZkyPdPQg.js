import{_ as s,o as e,c as a,R as n}from"./chunks/framework.3AywRrgj.js";const o="/zhaobao1830-notes/assets/01.Sd30iRQM.png",p="/zhaobao1830-notes/assets/02.HcwrYmBT.png",g=JSON.parse('{"title":"登录验证 cookie、session、token","description":"","frontmatter":{},"headers":[],"relativePath":"frontKnowledge/other/02.md","filePath":"frontKnowledge/other/02.md","lastUpdated":1703842863000}'),t={name:"frontKnowledge/other/02.md"},i=n(`<h1 id="登录验证-cookie、session、token" tabindex="-1">登录验证 cookie、session、token <a class="header-anchor" href="#登录验证-cookie、session、token" aria-label="Permalink to &quot;登录验证 cookie、session、token&quot;">​</a></h1><h2 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;cookie&quot;">​</a></h2><p>校验过程</p><p>1、前端输入用户名密码，传给后端</p><p>2、后端验证成功，返回信息时执行set-cookie，把值保存到cookie里（后端做）</p><p>3、前端所有的接口访问，会自动带上cookie（浏览器的默认行为，http协议的规定）</p><h2 id="session" tabindex="-1">session <a class="header-anchor" href="#session" aria-label="Permalink to &quot;session&quot;">​</a></h2><p><a href="https://www.cnblogs.com/zhaobao1830/p/11114146.html" target="_blank" rel="noreferrer">参考文章</a></p><p>已经有了cookie，为什么还需要session？</p><p>cookie的信息是暴露在外面的，如果把所有的信息都保存在cookie里，敏感信息会暴露。</p><p>一般操作：cookie只存储id，详细信息保存在session中</p><p>后端要保存信息到session中，需要使用HttpSession，调用session.setAttribute，生成sessionId，设置在 Set-Cookie响应头中，响应给客户端</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>@RequestMapping(value = &quot;login.do&quot;, method = RequestMethod.POST)</span></span>
<span class="line"><span>    @ResponseBody</span></span>
<span class="line"><span>    public ServerResponse&lt;User&gt; login(String username, String password, HttpSession session) {</span></span>
<span class="line"><span>        ServerResponse&lt;User&gt; response = iUserService.login(username, password);</span></span>
<span class="line"><span>        if (response.isSuccess()) {</span></span>
<span class="line"><span>            session.setAttribute(Const.CURRENT_USER, response.getData());</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return response;</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><img src="`+o+'" alt="Image text"></p><p>当客户端再次请求的时候，会把保存在cookie中的sessionId携带在Request Header中给到服务器，你只需要在服务器中再次使用代码</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>HttpSession session = request.getSession()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>来获取request中的session</p><p><img src="'+p+'" alt="Image text"></p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><p>1、原理简单，易于学习</p><p>2、用户信息存储在服务端，可以快速封禁某个登录的用户--有这方面强需求的人，一定选择session</p><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><p>1、占用服务端内存，有硬件成本</p><p>2、多进程、多服务时，不好同步--一般使用第三方redis存储，成本高</p><p>3、跨域传递cookie，需要特殊配置（没用过，不知道需要什么配置）</p><h2 id="jwt-json-web-token" tabindex="-1">JWT（JSON Web Token) <a class="header-anchor" href="#jwt-json-web-token" aria-label="Permalink to &quot;JWT（JSON Web Token)&quot;">​</a></h2><p>校验过程</p><p>1、前端输入用户名密码，传给后端</p><p>2、后端验证成功，返回token字符串（将用户信息&lt;加密规则跨域自己定&gt;加密后得到的）</p><p>3、前端获取token存储下来</p><p>4、前端访问接口，在header.token中携带</p><h3 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h3><p>1、不占用服务器内存</p><p>2、多进程、多服务器，不受影响</p><p>3、不受跨域限制</p><h3 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><p>无法快速封禁登录的用户</p><h3 id="jwt和session的区别" tabindex="-1">JWT和Session的区别 <a class="header-anchor" href="#jwt和session的区别" aria-label="Permalink to &quot;JWT和Session的区别&quot;">​</a></h3><p>1、JWT用户信息存储在客户端</p><p>2、Session用户信息存储在服务端</p><h3 id="为何选择jwt" tabindex="-1">为何选择JWT <a class="header-anchor" href="#为何选择jwt" aria-label="Permalink to &quot;为何选择JWT&quot;">​</a></h3><p>1、没有快速封禁登录用户的需求</p><p>2、JWT成本低，维护简单</p><p>3、需要考虑跨域的扩展性</p><div class="tip custom-block"><p class="custom-block-title">温馨提示</p><p>JWT的出现并不是为了解决安全性的，只是为了前后端分离而出现的，谁拿上这个钥匙都能访问</p><p>真要确保安全性，就把JWT的有效期设置的短一些</p></div>',45),r=[i];function l(c,d,h,u,b,m){return e(),a("div",null,r)}const _=s(t,[["render",l]]);export{g as __pageData,_ as default};
